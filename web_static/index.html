<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Champion Chat (Static)</title>
  <style>
    :root {
      --bg: #f3efe6;
      --panel: #fffaf0;
      --ink: #171717;
      --muted: #5e5a53;
      --line: #d8cfbf;
      --accent: #0f766e;
      --accent2: #b45309;
      --user: #e0f2fe;
      --bot: #eef2ff;
      --sys: #fef3c7;
      --shadow: rgba(23, 23, 23, 0.08);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: Georgia, "Times New Roman", serif;
      color: var(--ink);
      background:
        radial-gradient(circle at 10% 10%, rgba(180,83,9,.12), transparent 40%),
        radial-gradient(circle at 90% 15%, rgba(15,118,110,.10), transparent 45%),
        linear-gradient(180deg, #f7f2e9 0%, #f2ede3 100%);
      min-height: 100vh;
    }
    .wrap {
      max-width: 1000px;
      margin: 0 auto;
      padding: 18px;
      display: grid;
      gap: 12px;
    }
    .card {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 14px;
      box-shadow: 0 8px 24px var(--shadow);
    }
    .header {
      padding: 14px 16px;
      display: flex;
      gap: 10px;
      align-items: baseline;
      justify-content: space-between;
    }
    .title {
      margin: 0;
      font-size: 1.2rem;
      letter-spacing: .02em;
    }
    .subtitle {
      color: var(--muted);
      font-size: .9rem;
    }
    .controls {
      padding: 14px 16px;
      border-top: 1px solid var(--line);
      display: grid;
      gap: 12px;
    }
    .row {
      display: grid;
      gap: 8px;
      grid-template-columns: 1fr;
    }
    .row.inline {
      grid-template-columns: 1fr auto auto auto auto;
      align-items: center;
    }
    label {
      font-size: .84rem;
      color: var(--muted);
    }
    input[type="text"], select, button, textarea {
      font: inherit;
    }
    input[type="text"], select {
      width: 100%;
      padding: 9px 10px;
      border: 1px solid var(--line);
      background: #fff;
      border-radius: 10px;
      color: var(--ink);
    }
    input[type="file"] {
      font-size: .9rem;
    }
    button {
      border: 1px solid var(--line);
      border-radius: 10px;
      background: white;
      padding: 8px 12px;
      cursor: pointer;
    }
    button.primary {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }
    button:hover { filter: brightness(.98); }
    .status {
      margin: 0;
      padding: 10px 12px;
      border-top: 1px solid var(--line);
      background: #fff;
      border-radius: 0 0 14px 14px;
      font-size: .9rem;
      color: var(--muted);
    }
    .status.ok { color: #065f46; }
    .status.warn { color: #92400e; }
    .status.err { color: #991b1b; }
    .chat {
      display: grid;
      grid-template-rows: 1fr auto;
      min-height: 62vh;
    }
    .messages {
      padding: 14px;
      display: grid;
      gap: 10px;
      align-content: start;
      overflow-y: auto;
      max-height: 62vh;
    }
    .msg {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 9px 10px;
      background: #fff;
      white-space: pre-wrap;
      line-height: 1.35;
    }
    .msg.user { background: var(--user); }
    .msg.bot { background: var(--bot); }
    .msg.sys { background: var(--sys); color: #78350f; }
    .msg .meta {
      display: block;
      margin-bottom: 4px;
      font-size: .78rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .06em;
    }
    .composer {
      border-top: 1px solid var(--line);
      padding: 12px;
      display: grid;
      gap: 8px;
    }
    .composer-grid {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
    }
    textarea {
      width: 100%;
      min-height: 72px;
      max-height: 180px;
      resize: vertical;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 10px;
      background: white;
      color: var(--ink);
    }
    .footnote {
      font-size: .82rem;
      color: var(--muted);
    }
    details {
      border-top: 1px dashed var(--line);
      padding-top: 8px;
    }
    summary {
      cursor: pointer;
      color: var(--muted);
      font-size: .85rem;
    }
    #topCandidates {
      margin-top: 8px;
      font-size: .84rem;
      display: grid;
      gap: 6px;
    }
    .cand {
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 6px 8px;
      background: #fff;
    }
    .cand code {
      color: var(--accent2);
      font-size: .75rem;
    }
    @media (max-width: 780px) {
      .row.inline {
        grid-template-columns: 1fr 1fr;
      }
      .composer-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <section class="card">
      <div class="header">
        <div>
          <h1 class="title">Champion Chat (Static Web)</h1>
          <div class="subtitle">GitHub Pages-friendly chat using browser retrieval from metadata JSON</div>
        </div>
      </div>
      <div class="controls">
        <div class="row">
          <label for="metaUrl">Metadata JSON URL (same folder on GitHub Pages is easiest)</label>
          <input id="metaUrl" type="text" value="chat_model_meta_supermix_v27_500k.browser.json">
        </div>
        <div class="row">
          <label for="metaFile">Or load metadata JSON from your device</label>
          <input id="metaFile" type="file" accept=".json,application/json">
        </div>
        <div class="row inline">
          <select id="styleMode" title="Style mode">
            <option value="auto">Style: auto</option>
            <option value="balanced">Style: balanced</option>
            <option value="concise">Style: concise</option>
            <option value="analyst">Style: analyst</option>
            <option value="creative">Style: creative</option>
          </select>
          <select id="creativity" title="Creativity">
            <option value="0.0">Creativity 0.0</option>
            <option value="0.25">Creativity 0.25</option>
            <option value="0.5" selected>Creativity 0.5</option>
            <option value="0.75">Creativity 0.75</option>
            <option value="1.0">Creativity 1.0</option>
          </select>
          <select id="topK" title="Top K">
            <option value="20">Pool 20</option>
            <option value="40" selected>Pool 40</option>
            <option value="80">Pool 80</option>
            <option value="160">Pool 160</option>
          </select>
          <button id="loadBtn" class="primary">Load Metadata</button>
          <button id="clearBtn">Clear Chat</button>
        </div>
        <div class="footnote">
          Static browser mode uses the metadata JSON only. PyTorch <code>.pth</code> weights do not run on GitHub Pages.
        </div>
      </div>
      <p id="status" class="status warn">Load a metadata JSON file to start.</p>
    </section>

    <section class="card chat">
      <div id="messages" class="messages"></div>
      <div class="composer">
        <div class="composer-grid">
          <textarea id="userInput" placeholder="Type a message..."></textarea>
          <button id="sendBtn" class="primary">Send</button>
        </div>
        <details>
          <summary>Top candidates (debug)</summary>
          <div id="topCandidates"></div>
        </details>
      </div>
    </section>
  </div>

  <script>
    const state = {
      meta: null,
      candidates: [],
      history: [],
      recentAssistant: [],
      loading: false
    };

    const els = {
      metaUrl: document.getElementById('metaUrl'),
      metaFile: document.getElementById('metaFile'),
      loadBtn: document.getElementById('loadBtn'),
      clearBtn: document.getElementById('clearBtn'),
      status: document.getElementById('status'),
      messages: document.getElementById('messages'),
      userInput: document.getElementById('userInput'),
      sendBtn: document.getElementById('sendBtn'),
      topCandidates: document.getElementById('topCandidates'),
      styleMode: document.getElementById('styleMode'),
      creativity: document.getElementById('creativity'),
      topK: document.getElementById('topK')
    };

    const STOPWORDS = new Set([
      'the','a','an','and','or','but','if','then','so','to','of','in','on','for','with','at','by',
      'is','it','this','that','these','those','i','you','we','they','he','she','me','my','your','our',
      'be','am','are','was','were','do','does','did','can','could','would','should','will','just'
    ]);
    const TEMPLATE_BANNED = [
      /build a builder angle/i,
      /the for case for whether/i,
      /\[reflective-set\d+\]/i,
      /decision policy framing/i
    ];

    function setStatus(text, kind = 'warn') {
      els.status.textContent = text;
      els.status.className = `status ${kind}`;
    }

    function addMessage(role, text) {
      const box = document.createElement('div');
      box.className = `msg ${role}`;
      const meta = document.createElement('span');
      meta.className = 'meta';
      meta.textContent = role === 'user' ? 'You' : role === 'bot' ? 'Bot' : 'System';
      box.appendChild(meta);
      box.appendChild(document.createTextNode(text));
      els.messages.appendChild(box);
      els.messages.scrollTop = els.messages.scrollHeight;
    }

    function clearChat() {
      state.history = [];
      state.recentAssistant = [];
      els.messages.innerHTML = '';
      els.topCandidates.innerHTML = '';
      addMessage('sys', 'Chat cleared.');
    }

    function normalizeMeta(raw) {
      if (!raw || typeof raw !== 'object') throw new Error('Invalid metadata JSON');
      let candidates = [];
      let labelPriors = {};

      if (Array.isArray(raw.candidates)) {
        candidates = raw.candidates
          .map(r => ({
            label: String(r.label ?? ''),
            text: String(r.text ?? '').trim(),
            count: Number.isFinite(Number(r.count)) ? Number(r.count) : 1
          }))
          .filter(r => r.text);
        labelPriors = raw.label_priors || {};
      } else if (raw.buckets && typeof raw.buckets === 'object') {
        labelPriors = raw.label_priors || {};
        for (const [label, rows] of Object.entries(raw.buckets)) {
          if (!Array.isArray(rows)) continue;
          for (const row of rows) {
            if (!row || typeof row !== 'object') continue;
            const text = String(row.text || '').trim();
            if (!text) continue;
            candidates.push({
              label: String(label),
              text,
              count: Number.isFinite(Number(row.count)) ? Number(row.count) : 1
            });
          }
        }
      } else {
        throw new Error('Metadata JSON missing candidates/buckets');
      }

      return {
        raw,
        candidates,
        labelPriors,
        stats: {
          candidateCount: candidates.length,
          bucketCount: new Set(candidates.map(c => c.label)).size
        }
      };
    }

    function tokens(text) {
      return String(text || '').toLowerCase().match(/[a-z0-9_']+/g) || [];
    }

    function contentTokens(text) {
      return tokens(text).filter(t => t.length > 1 && !STOPWORDS.has(t));
    }

    function tokenSet(text) {
      return new Set(contentTokens(text));
    }

    function bigrams(text) {
      const t = contentTokens(text);
      const out = new Set();
      for (let i = 0; i < t.length - 1; i++) out.add(`${t[i]} ${t[i+1]}`);
      return out;
    }

    function jaccard(a, b) {
      if (!a.size && !b.size) return 0;
      let inter = 0;
      for (const x of a) if (b.has(x)) inter++;
      const union = a.size + b.size - inter;
      return union ? inter / union : 0;
    }

    function overlapRatio(a, b) {
      if (!a.size) return 0;
      let inter = 0;
      for (const x of a) if (b.has(x)) inter++;
      return inter / Math.max(1, a.size);
    }

    function inferStyleMode(query, selected) {
      if (selected && selected !== 'auto') return selected;
      const q = String(query || '').toLowerCase();
      if (/\b(short|brief|quick|tldr|one line)\b/.test(q)) return 'concise';
      if (/\b(step by step|debug|diagnose|tradeoff|explain why|analy[sz]e)\b/.test(q)) return 'analyst';
      if (/\b(creative|brainstorm|story|metaphor|analogy|imagine)\b/.test(q)) return 'creative';
      return 'balanced';
    }

    function detectDomains(text) {
      const q = String(text || '').toLowerCase();
      return {
        code: /```|traceback|python|javascript|typescript|api|sql|bug|error|exception|model|train/.test(q),
        science: /\b(science|physics|chemistry|biology|experiment|hypothesis|atom|molecule)\b/.test(q),
        math: /\b(math|algebra|equation|calculate|fraction|percent|solve)\b/.test(q) || /[0-9]+\s*[+\-*/=%]/.test(q),
        english: /\b(grammar|punctuation|rewrite|proofread|essay|sentence|paragraph)\b/.test(q),
        scripture: /\b(bible|scripture|verse|psalm|kjv|gospel|john|matthew)\b/.test(q),
        dictionary: /\b(define|definition|meaning|synonym|antonym|etymology|part of speech)\b/.test(q),
        literary: /\b(book|novel|character|theme|tone|literary|chapter|finnegans|joyce)\b/.test(q)
      };
    }

    function detectSmallTalk(query) {
      const q = String(query || '').trim().toLowerCase();
      if (!q) return null;
      if (/^(hi|hey|hello|yo|sup|good (morning|afternoon|evening))([!. ]*)$/.test(q)) {
        return 'Hi. What do you want help with: coding, writing, debugging, studying, or something else?';
      }
      if (/^(thanks|thank you|thx)([!. ]*)$/.test(q)) {
        return 'You’re welcome.';
      }
      if (/^(sorry|sorry\?|my bad|oops)([!. ]*)$/.test(q)) {
        return 'No problem. Do you want me to clarify the last answer or answer a new question?';
      }
      if (/^how can you help me([?.!]*)$/.test(q) || /^what can you do([?.!]*)$/.test(q)) {
        return 'I can help with coding, debugging, explanations, writing, study questions, and step-by-step problem solving. Ask something specific and I’ll answer directly.';
      }
      if (/^(what\?|huh\?|sorry\?\s*what)/.test(q)) {
        return 'I can clarify. Tell me which part was unclear, or paste the exact line you want explained.';
      }
      return null;
    }

    function isTemplateArtifact(text) {
      return TEMPLATE_BANNED.some(re => re.test(text || ''));
    }

    function styleAdjust(text, query, mode, creativity) {
      let out = String(text || '').trim();
      if (!out) return out;

      if (mode === 'concise') {
        const first = (out.match(/[^.!?]+[.!?]?/) || [out])[0].trim();
        const words = first.split(/\s+/);
        out = words.length > 28 ? words.slice(0, 28).join(' ').replace(/[,:;]+$/, '') + '.' : first;
        return out;
      }

      if (mode === 'analyst') {
        if (!/^\s*(1[\).]|first\b)/i.test(out)) {
          const parts = out.match(/[^.!?]+[.!?]?/g) || [out];
          if (parts.length >= 2) out = `1) ${parts[0].trim()} 2) ${parts[1].trim()}`;
          else out = `1) ${out}`;
        }
        return out;
      }

      if (mode === 'creative' && creativity > 0.35) {
        if (!/^(Creative take:|Fresh angle:|Idea sketch:|Consider this perspective:)/i.test(out)) {
          const intros = [
            'Fresh angle:',
            'Creative take:',
            'Idea sketch:',
            'Consider this perspective:'
          ];
          const pick = intros[Math.floor(Math.random() * intros.length)];
          out = `${pick} ${out}`;
        }
      }
      return out;
    }

    function renderTopCandidates(items) {
      els.topCandidates.innerHTML = '';
      for (const row of items) {
        const div = document.createElement('div');
        div.className = 'cand';
        const preview = row.text.length > 220 ? row.text.slice(0, 220) + '...' : row.text;
        div.innerHTML = `<code>score=${row.score.toFixed(3)} label=${row.label} count=${row.count}</code><div>${escapeHtml(preview)}</div>`;
        els.topCandidates.appendChild(div);
      }
    }

    function escapeHtml(s) {
      return String(s)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/\"/g, '&quot;');
    }

    function rankCandidates(query) {
      const q = String(query || '').trim();
      const qTokens = tokenSet(q);
      const qBigrams = bigrams(q);
      const historyText = state.history.slice(-4)
        .map(turn => `user: ${turn.user}\nassistant: ${turn.bot}`)
        .join('\n');
      const ctxTokens = tokenSet(historyText + '\n' + q);
      const qDomains = detectDomains(q);
      const genericShort = qTokens.size <= 4;
      const recentSet = new Set(state.recentAssistant.slice(-3).map(s => String(s).trim()).filter(Boolean));

      const scored = [];
      for (const c of state.candidates) {
        const text = c.text;
        const tSet = tokenSet(text);
        if (!tSet.size) continue;
        const bSet = bigrams(text);

        const qOverlap = overlapRatio(qTokens, tSet);
        const qJacc = jaccard(qTokens, tSet);
        const bgOverlap = qBigrams.size ? overlapRatio(qBigrams, bSet) : 0;
        const ctxOverlap = overlapRatio(ctxTokens, tSet);
        const lenTokens = Math.max(1, contentTokens(text).length);
        const conciseSignal = Math.min(1, 18 / lenTokens);
        const analyticSignal =
          (/\b(step|first|second|third|because|therefore|verify)\b/i.test(text) ? 0.6 : 0) +
          (/^\s*\d+[.)]\s/m.test(text) ? 0.3 : 0);
        const creativeSignal =
          (/\b(creative|imagine|metaphor|analogy|story|vivid|brainstorm)\b/i.test(text) ? 0.55 : 0) +
          (/[;:]/.test(text) ? 0.12 : 0);
        const empathySignal = /\b(i understand|that sounds|no problem|it's okay|you’re not alone|you're not alone)\b/i.test(text) ? 0.4 : 0;
        let domain = 0;
        if (qDomains.code && /\b(code|debug|error|python|api|traceback|function|class)\b/i.test(text)) domain += 0.2;
        if (qDomains.science && /\b(science|physics|chemistry|biology|experiment|hypothesis)\b/i.test(text)) domain += 0.2;
        if (qDomains.math && /\b(math|algebra|equation|calculate|fraction|percent|solve)\b/i.test(text)) domain += 0.2;
        if (qDomains.english && /\b(grammar|rewrite|proofread|sentence|paragraph|essay)\b/i.test(text)) domain += 0.2;
        if (qDomains.scripture && /\b(bible|scripture|verse|chapter|psalm|gospel|kjv)\b/i.test(text)) domain += 0.2;
        if (qDomains.dictionary && /\b(definition|define|synonym|antonym|part of speech|meaning)\b/i.test(text)) domain += 0.2;
        if (qDomains.literary && /\b(novel|chapter|character|theme|tone|literary|joyce|finnegans)\b/i.test(text)) domain += 0.2;

        const countBonus = Math.min(0.22, Math.log1p(Math.max(1, c.count)) / 30);
        const prior = Number(state.meta?.labelPriors?.[c.label] ?? 0) || 0;
        const priorBonus = Math.min(0.08, prior * 0.08);
        const repeatPenalty = recentSet.has(text) ? 0.45 : 0;
        const templatePenalty = isTemplateArtifact(text) ? (genericShort ? 0.8 : 0.25) : 0;
        const weirdPenalty = genericShort && /(?:\[[^\]]+\]|policy framing|youth populations)/i.test(text) ? 0.5 : 0;
        const convoBoost = genericShort && /\b(help|clarify|what|want|can|tell me)\b/i.test(text) ? 0.12 : 0;

        let score = 0.58 * ctxOverlap + 0.30 * qOverlap + 0.18 * qJacc + 0.22 * bgOverlap + domain + countBonus + priorBonus + convoBoost;
        const mode = inferStyleMode(q, els.styleMode.value);
        if (mode === 'concise') score += 0.18 * conciseSignal - 0.05 * creativeSignal;
        else if (mode === 'analyst') score += 0.16 * analyticSignal + 0.05 * domain;
        else if (mode === 'creative') score += 0.16 * creativeSignal + 0.06 * Math.min(1, lenTokens / 32);
        else score += 0.08 * empathySignal + 0.06 * analyticSignal;

        score -= repeatPenalty + templatePenalty + weirdPenalty;

        scored.push({ ...c, score });
      }

      scored.sort((a, b) => b.score - a.score);
      return scored;
    }

    function chooseResponse(query, ranked) {
      if (!ranked.length) return 'I do not have a response loaded yet. Load metadata first.';
      const mode = inferStyleMode(query, els.styleMode.value);
      const creativity = Number(els.creativity.value || 0.5);
      const top = ranked.slice(0, Math.max(1, Math.min(Number(els.topK.value || 40), ranked.length)));

      let chosen = top[0];
      if (mode === 'creative' && creativity > 0.2) {
        const n = Math.min(5, top.length);
        const pool = top.slice(0, n);
        const temp = 0.35 + creativity * 0.8;
        const weights = pool.map(r => Math.exp(r.score / Math.max(0.15, temp)));
        const sum = weights.reduce((a,b) => a+b, 0) || 1;
        let x = Math.random() * sum;
        for (let i = 0; i < pool.length; i++) {
          x -= weights[i];
          if (x <= 0) { chosen = pool[i]; break; }
        }
      }

      return styleAdjust(chosen.text, query, mode, creativity);
    }

    async function loadMetaFromUrl(url) {
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) throw new Error(`HTTP ${res.status} loading ${url}`);
      return res.json();
    }

    function loadMetaFromFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          try { resolve(JSON.parse(reader.result)); }
          catch (e) { reject(e); }
        };
        reader.onerror = () => reject(reader.error || new Error('File read failed'));
        reader.readAsText(file);
      });
    }

    async function doLoad() {
      if (state.loading) return;
      state.loading = true;
      els.loadBtn.disabled = true;
      try {
        setStatus('Loading metadata...', 'warn');
        let raw;
        const file = els.metaFile.files && els.metaFile.files[0];
        if (file) raw = await loadMetaFromFile(file);
        else raw = await loadMetaFromUrl(els.metaUrl.value.trim());

        const meta = normalizeMeta(raw);
        state.meta = meta;
        state.candidates = meta.candidates;
        setStatus(`Loaded ${meta.stats.candidateCount} candidates across ${meta.stats.bucketCount} buckets.`, 'ok');
        addMessage('sys', `Loaded metadata. Candidates: ${meta.stats.candidateCount}.`);
        if (!state.history.length) {
          addMessage('bot', 'Static web chat is ready. Ask a question.');
        }
      } catch (err) {
        console.error(err);
        setStatus(`Load failed: ${err.message || err}`, 'err');
      } finally {
        els.loadBtn.disabled = false;
        state.loading = false;
      }
    }

    async function onSend() {
      const user = els.userInput.value.trim();
      if (!user) return;
      addMessage('user', user);
      els.userInput.value = '';

      if (!state.candidates.length) {
        const msg = 'Load a metadata JSON first.';
        addMessage('bot', msg);
        return;
      }

      const t0 = performance.now();
      const smallTalk = detectSmallTalk(user);
      let bot;
      let ranked = [];
      if (smallTalk) {
        bot = smallTalk;
      } else {
        ranked = rankCandidates(user);
        renderTopCandidates(ranked.slice(0, 8));
        bot = chooseResponse(user, ranked);
      }
      const dt = performance.now() - t0;

      addMessage('bot', bot);
      addMessage('sys', `Timing: ${dt.toFixed(1)} ms`);

      state.history.push({ user, bot });
      state.recentAssistant.push(bot);
      if (state.history.length > 20) state.history = state.history.slice(-20);
      if (state.recentAssistant.length > 8) state.recentAssistant = state.recentAssistant.slice(-8);
    }

    els.loadBtn.addEventListener('click', doLoad);
    els.clearBtn.addEventListener('click', clearChat);
    els.sendBtn.addEventListener('click', onSend);
    els.userInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        onSend();
      }
    });

    clearChat();
  </script>
</body>
</html>
