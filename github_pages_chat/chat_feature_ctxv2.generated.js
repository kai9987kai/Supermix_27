// Generated by export_chat_browser_onnx.py. Do not hand-edit.
(function(global) {
  const CFG = {"feat_dim":128,"model_classes":10,"regex":{"TOKEN_RE":{"pattern":"[A-Za-z0-9_']+|[^\\w\\s]","flags":""},"PROGRAMMING_HINT_RE":{"pattern":"```|`[^`]+`|\\b(def|class|import|from|return|async|await|SELECT|INSERT|UPDATE|DELETE|function|const|let|var|public|private|try|except|catch|lambda|pip|npm|pytest|traceback|stack trace|segfault|nullpointer|keyerror|indexerror)\\b","flags":"i"},"SCIENCE_HINT_RE":{"pattern":"\\b(science|scientific|physics|chemistry|biology|geology|astronomy|ecology|cell|atom|molecule|energy|force|gravity|photosynthesis|ecosystem|planet|star|weather|climate|experiment|hypothesis)\\b","flags":"i"},"ENGLISH_HINT_RE":{"pattern":"\\b(english|grammar|punctuation|spelling|vocabulary|sentence|paragraph|essay|rewrite|paraphrase|formal|informal|proofread|edit|thesis|topic sentence)\\b","flags":"i"},"MATH_HINT_RE":{"pattern":"\\b(math|mathematics|arithmetic|add|subtract|multiply|divide|fraction|decimal|percent|percentage|ratio|algebra|equation|solve|simplify|calculate|average|mean)\\b|[0-9]+\\s*[%+\\-*/=]","flags":"i"},"SCRIPTURE_REF_RE":{"pattern":"\\b(?:genesis|exodus|leviticus|numbers|deuteronomy|joshua|judges|ruth|samuel|kings|chronicles|ezra|nehemiah|esther|job|psalm|psalms|proverbs|ecclesiastes|isaiah|jeremiah|ezekiel|daniel|hosea|joel|amos|obadiah|jonah|micah|nahum|habakkuk|zephaniah|haggai|zechariah|malachi|matthew|mark|luke|john|acts|romans|corinthians|galatians|ephesians|philippians|colossians|thessalonians|timothy|titus|philemon|hebrews|james|peter|jude|revelation)\\s+\\d+(?::\\d+(?:-\\d+)?)?\\b","flags":"i"},"SCRIPTURE_HINT_RE":{"pattern":"\\b(bible|scripture|verse|verses|chapter|gospel|psalm|psalms|parable|apostle|prophet|genesis|exodus|john|matthew|romans|revelation|old testament|new testament|kjv)\\b","flags":"i"},"DICTIONARY_HINT_RE":{"pattern":"\\b(dictionary|define|definition|meaning|meanings|vocabulary|word meaning|synonym|synonyms|antonym|antonyms|part of speech|pronunciation|etymology|lemma)\\b","flags":"i"},"CODE_HINT_RE":{"pattern":"`[^`]+`|\\b(traceback|stack|error|exception|python|sql|api|model|train|javascript|typescript|java|c\\+\\+|c#|bash|regex|json|yaml|docker|kubernetes)\\b","flags":"i"},"ROLE_LINE_RE":{"pattern":"^(user|assistant|system|tool|memory \\d+ user|memory \\d+ assistant)\\s*:\\s*(.*)$","flags":"i"},"IDENTIFIER_TOKEN_RE":{"pattern":"[A-Za-z_][A-Za-z0-9_]{2,}","flags":""},"CAMEL_OR_WORD_RE":{"pattern":"[A-Z]+(?=[A-Z][a-z]|\\d|$)|[A-Z]?[a-z]+|\\d+","flags":""},"CODE_LINE_SHAPE_WORD_RE":{"pattern":"[A-Za-z_][A-Za-z0-9_]*","flags":""}},"sets":{"PROGRAMMING_WORDS":["api","array","bash","c","c#","c++","class","compile","conda","css","database","debug","dict","docker","exception","function","git","go","golang","graphql","html","http","import","index","java","javascript","json","kotlin","kubernetes","list","loop","method","migration","module","npm","numpy","object","package","pandas","php","pip","powershell","pytest","python","query","rest","return","ruby","runtime","rust","schema","shell","sql","stack","swift","tensorflow","torch","traceback","typescript","unittest","venv","xml","yaml"],"CREATIVE_WORDS":["analogy","brainstorm","creative","imagine","invent","metaphor","novel","story","vivid"],"ANALYTIC_WORDS":["because","debug","diagnose","first","measure","plan","second","step","therefore","tradeoff","verify"],"SCIENCE_WORDS":["Evil","Nitrogen","Oxygen","United Kingdom","WiFiNews","acceleration","astronomy","atom","biology","cave","cell","chemical","chemistry","circuit","climate","compound","control","current","data","density","dna","earth","ecology","ecosystem","electron","element","energy","evidence","experiment","force","frequency","friction","gas","gene","geology","gravity","habitat","hypothesis","light","liquid","mass","matter","measurement","mixture","molecule","moon","motion","neutron","observation","orbit","organ","organism","photosynthesis","physical","physics","planet","plasma","power","proton","pub","reaction","resistance","respiration","revolution","rock cycle","rotation","science","scientific","si","solar","solid","sound","species","star","sun","system","theory","tissue","tower","tractor","unit","units","variable","velocity","voltage","volume","water cycle","wave","wavelength","weather","work"],"ENGLISH_WORDS":["adjective","adverb","antonym","apostrophe","article","capitalization","capitalize","colon","comma","concise","definition","edit","english","essay","formal","grammar","informal","noun","paragraph","paraphrase","period","plural","preposition","pronoun","proofread","punctuation","revise","rewrite","semicolon","sentence","sentences","singular","spelling","subject","synonym","tense","thesis","tone","topic","transition","verb","vocabulary","voice","word","words"],"MATH_WORDS":["addition","algebra","arithmetic","average","calculate","calculation","conversion","convert","decimal","decimals","difference","divide","divided","division","equals","equation","fraction","fractions","greater","integer","less","math","mathematics","mean","median","multiplication","multiplied","multiply","negative","number","numbers","percent","percentage","positive","product","proportion","quotient","ratio","remainder","simplify","solve","subtraction","sum","units"],"SCRIPTURE_WORDS":["apostle","apostles","bible","chapter","chapters","christ","covenant","exodus","faith","genesis","god","gospel","gospels","grace","isaiah","jesus","john","kingdom","kjv","lord","matthew","mercy","parable","prayer","prophet","prophets","psalm","psalms","revelation","romans","salvation","scripture","scriptures","testament","verse","verses"],"DICTIONARY_WORDS":["adjective","adverb","antonym","antonyms","define","definition","dictionary","etymology","example","examples","lemma","lexicon","meaning","meanings","noun","pronunciation","synonym","synonyms","usage","verb","vocabulary","word","words"]}};
  const FEAT_DIM = CFG.feat_dim;
  const MODEL_CLASSES = CFG.model_classes;
  const RX = {};
  for (const [k, v] of Object.entries(CFG.regex)) {
    RX[k] = new RegExp(v.pattern, v.flags);
  }
  const SETS = {};
  for (const [k, arr] of Object.entries(CFG.sets)) {
    SETS[k] = new Set(arr);
  }

  const enc = new TextEncoder();
  const _featCache = new Map();
  const _textTmp = new Float32Array(FEAT_DIM);

  function _requireBlake() {
    if (typeof global.blake2b === 'function') return global.blake2b;
    if (global.blakejs && typeof global.blakejs.blake2b === 'function') return global.blakejs.blake2b;
    throw new Error('blake2b function not found. Load blakejs before chat_feature_ctxv2.generated.js');
  }

  function _stableHash64(text) {
    const blake2b = _requireBlake();
    const out = blake2b(enc.encode(String(text)), null, 8);
    let h = 0n;
    for (let i = 0; i < 8; i++) {
      h |= BigInt(out[i]) << BigInt(8 * i); // little-endian
    }
    return h;
  }

  function _hashAdd(vec, key, weight, dim = FEAT_DIM, signBit = 1) {
    const h = _stableHash64(key);
    const idx = Number(h % BigInt(dim));
    const sign = (((h >> BigInt(signBit)) & 1n) === 0n) ? 1.0 : -1.0;
    vec[idx] += Number(weight) * sign;
  }

  function _tokens(text, maxTokens = 384) {
    const m = String(text || '').toLowerCase().match(RX.TOKEN_RE);
    if (!m) return [];
    return m.slice(0, maxTokens);
  }

  function _identifierSubtokens(token, maxParts = 8) {
    const raw = String(token || '').replace(/^[`'"]+|[`'"]+$/g, '');
    if (!raw) return [];
    const chunks = raw.split(/[_\-./:]+/);
    const parts = [];
    for (const chunk0 of chunks) {
      const chunk = chunk0.trim();
      if (!chunk) continue;
      const matches = chunk.match(RX.CAMEL_OR_WORD_RE);
      if (matches && matches.length) parts.push(...matches);
      else parts.push(chunk);
    }
    const out = [];
    for (const p0 of parts) {
      const p = String(p0).toLowerCase().trim();
      if (p.length >= 2) out.push(p);
      if (out.length >= maxParts) break;
    }
    return out;
  }

  function _looksCodeLikeLine(line) {
    const s = String(line || '').replace(/\r?$/, '');
    if (!s) return false;
    if (s.startsWith('```')) return true;
    if (s.startsWith('    ') || s.startsWith('\t')) return true;
    if (/\b(def|class|import|from|return|if|else|for|while|try|except|catch|function|const|let|var|SELECT|INSERT|UPDATE|DELETE)\b/.test(s)) return true;
    const punct = (s.match(/[{}();]/g) || []).length;
    if (punct >= 2) return true;
    if (s.includes('=>') || s.includes('::') || s.includes('->')) return true;
    return false;
  }

  function _zeros() {
    return new Float32Array(FEAT_DIM);
  }

  function _l2Normalize(vec) {
    let ss = 0.0;
    for (let i = 0; i < vec.length; i++) ss += vec[i] * vec[i];
    if (ss <= 0) return vec;
    const inv = 1.0 / Math.sqrt(ss);
    for (let i = 0; i < vec.length; i++) vec[i] *= inv;
    return vec;
  }

  function _cloneVec(vec) {
    return new Float32Array(vec);
  }

  function _addScaled(acc, vec, w) {
    for (let i = 0; i < acc.length; i++) acc[i] += vec[i] * w;
    return acc;
  }

  function _featurizeTextImpl(text, dim = FEAT_DIM) {
    if (dim !== FEAT_DIM) throw new Error('Generated browser encoder only supports dim=128');
    const vec = _zeros();
    const toks = _tokens(text);
    if (!toks.length) return vec;

    for (const tok of toks) {
      const h = _stableHash64('u|' + tok);
      const idx = Number(h % BigInt(dim));
      const sign = (((h >> 1n) & 1n) === 0n) ? 1.0 : -1.0;
      vec[idx] += sign;
    }

    for (let i = 0; i < toks.length - 1; i++) {
      const bg = toks[i] + '__' + toks[i + 1];
      const h = _stableHash64('b|' + bg);
      const idx = Number(h % BigInt(dim));
      const sign = (((h >> 2n) & 1n) === 0n) ? 1.0 : -1.0;
      vec[idx] += 0.75 * sign;
    }

    let codeHits = 0, creativeHits = 0, analyticHits = 0, scienceHits = 0;
    let englishHits = 0, mathHits = 0, scriptureHits = 0, dictHits = 0;

    for (const tok of toks) {
      if (SETS.PROGRAMMING_WORDS.has(tok)) {
        codeHits += 1;
        _hashAdd(vec, 'kw|code|' + tok, 1.10, dim, 3);
      }
      if (SETS.CREATIVE_WORDS.has(tok)) {
        creativeHits += 1;
        _hashAdd(vec, 'kw|creative|' + tok, 0.55, dim, 4);
      }
      if (SETS.ANALYTIC_WORDS.has(tok)) {
        analyticHits += 1;
        _hashAdd(vec, 'kw|analytic|' + tok, 0.55, dim, 5);
      }
      if (SETS.SCIENCE_WORDS.has(tok)) {
        scienceHits += 1;
        _hashAdd(vec, 'kw|science|' + tok, 0.82, dim, 46);
      }
      if (SETS.ENGLISH_WORDS.has(tok)) {
        englishHits += 1;
        _hashAdd(vec, 'kw|english|' + tok, 0.75, dim, 26);
      }
      if (SETS.MATH_WORDS.has(tok)) {
        mathHits += 1;
        _hashAdd(vec, 'kw|math|' + tok, 0.90, dim, 27);
      }
      if (SETS.SCRIPTURE_WORDS.has(tok)) {
        scriptureHits += 1;
        _hashAdd(vec, 'kw|scripture|' + tok, 0.80, dim, 64);
      }
      if (SETS.DICTIONARY_WORDS.has(tok)) {
        dictHits += 1;
        _hashAdd(vec, 'kw|dictionary|' + tok, 0.72, dim, 62);
      }
    }

    const rawIdentifiers = String(text || '').match(RX.IDENTIFIER_TOKEN_RE) || [];
    for (const ident of rawIdentifiers.slice(0, 96)) {
      const subtoks = _identifierSubtokens(ident, 8);
      if (!subtoks.length) continue;
      if (subtoks.length >= 2) codeHits += 1;
      for (const sub of subtoks) _hashAdd(vec, 'id|' + sub, 0.40, dim, 6);
      if (ident.length >= 5) {
        _hashAdd(vec, 'idh|' + ident.slice(0, 4).toLowerCase(), 0.18, dim, 7);
        _hashAdd(vec, 'idt|' + ident.slice(-4).toLowerCase(), 0.18, dim, 8);
      }
    }

    const textStr = String(text || '');
    if (RX.PROGRAMMING_HINT_RE.test(textStr)) {
      codeHits += 2;
      _hashAdd(vec, 'domain|code_hint', 0.90, dim, 9);
    }
    if (RX.SCIENCE_HINT_RE.test(textStr)) {
      scienceHits += 2;
      _hashAdd(vec, 'domain|science_hint', 0.78, dim, 47);
    }
    if (RX.ENGLISH_HINT_RE.test(textStr)) {
      englishHits += 2;
      _hashAdd(vec, 'domain|english_hint', 0.70, dim, 28);
    }
    if (RX.MATH_HINT_RE.test(textStr)) {
      mathHits += 2;
      _hashAdd(vec, 'domain|math_hint', 0.85, dim, 29);
    }
    if (RX.SCRIPTURE_HINT_RE.test(textStr) || RX.SCRIPTURE_REF_RE.test(textStr)) {
      scriptureHits += 2;
      _hashAdd(vec, 'domain|scripture_hint', 0.78, dim, 65);
    }
    if (RX.DICTIONARY_HINT_RE.test(textStr)) {
      dictHits += 2;
      _hashAdd(vec, 'domain|dictionary_hint', 0.72, dim, 63);
    }

    let codeLikeLines = 0;
    for (const line of textStr.split(/\r?\n/).slice(0, 16)) {
      if (!_looksCodeLikeLine(line)) continue;
      codeLikeLines += 1;
      let shape = line.trim();
      shape = shape.replace(RX.CODE_LINE_SHAPE_WORD_RE, 'ID');
      shape = shape.replace(/\d+/g, 'N');
      shape = shape.replace(/"[^"]*"|'[^']*'/g, 'STR');
      shape = shape.replace(/\s+/g, ' ').slice(0, 96);
      if (shape) _hashAdd(vec, 'line|' + shape, 0.65, dim, 10);
    }

    if (codeHits > 0 || codeLikeLines > 0) _hashAdd(vec, 'domain|code', Math.min(1.25, 0.18 * (codeHits + codeLikeLines)), dim, 11);
    if (scienceHits > 0) _hashAdd(vec, 'domain|science', Math.min(1.0, 0.15 * scienceHits), dim, 48);
    if (englishHits > 0) _hashAdd(vec, 'domain|english', Math.min(0.95, 0.14 * englishHits), dim, 30);
    if (mathHits > 0) _hashAdd(vec, 'domain|math', Math.min(1.05, 0.16 * mathHits), dim, 31);
    if (scriptureHits > 0) _hashAdd(vec, 'domain|scripture', Math.min(1.0, 0.15 * scriptureHits), dim, 66);
    if (dictHits > 0) _hashAdd(vec, 'domain|dictionary', Math.min(0.95, 0.14 * dictHits), dim, 53);
    if (creativeHits > 0) _hashAdd(vec, 'domain|creative', Math.min(0.70, 0.12 * creativeHits), dim, 12);
    if (analyticHits > 0) _hashAdd(vec, 'domain|analytic', Math.min(0.70, 0.12 * analyticHits), dim, 13);

    return _l2Normalize(vec);
  }

  function featurizeText(text, dim = FEAT_DIM) {
    if (dim !== FEAT_DIM) throw new Error('Generated browser encoder only supports dim=128');
    const clean = String(text || '').trim();
    if (!clean) return _zeros();
    const hit = _featCache.get(clean);
    if (hit) return _cloneVec(hit);
    const vec = _featurizeTextImpl(clean, dim);
    if (_featCache.size > 50000) _featCache.clear();
    _featCache.set(clean, _cloneVec(vec));
    return vec;
  }

  function _splitRoleLine(line) {
    const m = RX.ROLE_LINE_RE.exec(String(line || '').trim());
    if (!m) return ['text', String(line || '').trim()];
    return [String(m[1]).trim().toLowerCase(), String(m[2] || '').trim()];
  }

  function featurizeContextV2(contextText, dim = FEAT_DIM, maxLines = 32) {
    if (dim !== FEAT_DIM) throw new Error('Generated browser encoder only supports dim=128');
    const raw = String(contextText || '').trim();
    if (!raw) return _zeros();
    let lines = raw.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    if (!lines.length) return featurizeText(raw, dim);
    if (lines.length > maxLines) lines = lines.slice(-maxLines);

    const roleWeights = {
      user: 1.20,
      assistant: 0.95,
      system: 0.85,
      tool: 0.88,
      memory_user: 1.05,
      memory_assistant: 0.90,
      text: 1.00,
    };
    const acc = _zeros();
    const n = lines.length;
    const questionBoost = featurizeText('[question_intent]', dim);
    const actionBoost = featurizeText('[action_request]', dim);

    for (let idx = 0; idx < lines.length; idx++) {
      const [role0, content] = _splitRoleLine(lines[idx]);
      if (!content) continue;
      let roleKey = role0;
      if (role0.startsWith('memory ') && role0.includes(' user')) roleKey = 'memory_user';
      else if (role0.startsWith('memory ') && role0.includes(' assistant')) roleKey = 'memory_assistant';
      if (!(roleKey in roleWeights)) roleKey = 'text';

      const recency = 0.55 + 0.45 * (idx + 1) / Math.max(1, n);
      const weight = recency * roleWeights[roleKey];
      _addScaled(acc, featurizeText('[' + roleKey + '] ' + content, dim), weight);

      const lower = content.toLowerCase();
      if (content.includes('?')) _addScaled(acc, questionBoost, 0.035);
      if (/\b(please|can you|could you|help|build|fix|make|optimi[sz]e)\b/.test(lower)) {
        _addScaled(acc, actionBoost, 0.030);
      }
    }
    return _l2Normalize(acc);
  }

  function buildContext(history, userText, maxTurns = 4) {
    const parts = [];
    const h = Array.isArray(history) ? history : [];
    for (const turn of h.slice(-Math.max(0, maxTurns))) {
      if (Array.isArray(turn)) {
        parts.push('User: ' + (turn[0] || ''));
        parts.push('Assistant: ' + (turn[1] || ''));
      } else if (turn && typeof turn === 'object') {
        parts.push('User: ' + (turn.user || ''));
        parts.push('Assistant: ' + (turn.bot || turn.assistant || ''));
      }
    }
    parts.push('User: ' + (userText || ''));
    return parts.join('\n');
  }

  function textToModelInput(text, featureMode = 'legacy') {
    const mode = String(featureMode || 'legacy').trim().toLowerCase();
    const vec = (mode === 'context_v2') ? featurizeContextV2(text, FEAT_DIM) : featurizeText(text, FEAT_DIM);
    return vec; // Float32Array length 128
  }

  global.ChatFeatureCtxV2 = {
    FEAT_DIM,
    MODEL_CLASSES,
    featurizeText,
    featurizeContextV2,
    buildContext,
    textToModelInput,
    _version: 'ctxv2-js-1',
  };
})(typeof globalThis !== 'undefined' ? globalThis : window);
